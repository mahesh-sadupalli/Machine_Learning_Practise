# -*- coding: utf-8 -*-
"""clustering_algorithms.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sUfARLo2t9VsEkhwEjgd1epoaYDNZ6yy
"""

# Foundations of Data Mining - Practical Task 1
# Version 2.0 (2023-11-02)
###############################################
# Template for a custom clustering library.
# Classes are partially compatible to scikit-learn.
# Aside from check_array, do not import functions from scikit-learn, tensorflow, keras or related libraries!
# Do not change the signatures of the given functions or the class names!

import numpy as np
from sklearn.utils import check_array
import cv2
import matplotlib.pyplot as plt
import sys
import random
from PIL import Image
from matplotlib.pyplot import imshow


class CustomKMeans:
    def __init__(self, n_clusters=8, max_iter=300, random_state=None):
        """
        Creates an instance of CustomKMeans.
        :param n_clusters: Amount of target clusters (=k).
        :param max_iter: Maximum amount of iterations before the fitting stops (optional).
        :param random_state: Initialization for randomizer (optional).
        """
        self.n_clusters = n_clusters
        self.max_iter = max_iter
        self.random_state = random_state
        self.cluster_centers_ = None
        self.labels_ = None

    def fit(self, X: np.ndarray, y=None):
        np.random.seed(self.random_state)
        X = check_array(X, accept_sparse='csr')

        # Initialize centroids randomly from the data points
        centroids = X[np.random.choice(X.shape[0], self.n_clusters, replace=False)]
        for _ in range(self.max_iter):
            # Assign clusters based on closest centroid
            distances = np.linalg.norm(X - centroids[:, np.newaxis], axis=2)
            self.labels_ = np.argmin(distances, axis=0)

            # Recalculate centroids as mean of assigned points
            new_centroids = np.array([X[self.labels_ == i].mean(axis=0) for i in range(self.n_clusters)])
            if np.all(centroids == new_centroids):
                break
            centroids = new_centroids

        self.cluster_centers_ = centroids
        return self


    def fit_predict(self, X: np.ndarray, y=None) -> np.ndarray:
        """
        Calls fit() and immediately returns the labels. See fit() for parameter information.
        """
        self.fit(X)
        return self.labels_


class CustomDBSCAN:
    def __init__(self, eps=0.5, min_samples=5, metric='euclidean'):
        """
        Creates an instance of CustomDBSCAN.
        :param min_samples: Equivalent to minPts. Minimum amount of neighbors of a core object.
        :param eps: Short for epsilon. Radius of considered circle around a possible core object.
        :param metric: Used metric for measuring distances (optional).
        """
        self.eps = eps
        self.min_samples = min_samples
        self.metric = metric
        self.labels_ = None

    def fit(self, X: np.ndarray, y=None):
        X = check_array(X, accept_sparse='csr')

        labels = np.full(len(X), -1)  # -1 for unvisited points
        cluster_id = 0

        for i in range(len(X)):
            if labels[i] != -1:
                continue

            # Find neighbors
            neighbors = self.range_query(X, X[i])

            if len(neighbors) < self.min_samples:
                labels[i] = 0  # Mark as noise
                continue

            # Found a core point, create a new cluster
            labels[i] = cluster_id
            seeds = set(neighbors) - {i}

            while seeds:
                current_point = seeds.pop()
                if labels[current_point] == -1:
                    labels[current_point] = cluster_id
                    new_neighbors = self.range_query(X, X[current_point])
                    if len(new_neighbors) >= self.min_samples:
                        seeds.update(new_neighbors)
                elif labels[current_point] == 0:  # Previously marked as noise
                    labels[current_point] = cluster_id

            cluster_id += 1

        self.labels_ = labels
        return self

    def range_query(self, X, point):
        """Find all points within eps of point."""
        neighbors = []
        for i in range(len(X)):
            if np.linalg.norm(X[i] - point) <= self.eps:
                neighbors.append(i)
        return neighbors


    def fit_predict(self, X: np.ndarray, y=None) -> np.ndarray:
        """
        Calls fit() and immediately returns the labels. See fit() for parameter information.
        """
        self.fit(X)
        return self.labels_

